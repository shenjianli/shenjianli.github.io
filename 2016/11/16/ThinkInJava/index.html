<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>ThinkInJava | 撑起头顶的天</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第 1 章  对象入门面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。 1.1 抽象的进步五大基本特征: 所有东西都是对象 程序是一大堆对象的组合 每个对象都有自己的存储空间，可容">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="ThinkInJava">
<meta property="og:url" content="http://yoursite.com/2016/11/16/ThinkInJava/index.html">
<meta property="og:site_name" content="撑起头顶的天">
<meta property="og:description" content="第 1 章  对象入门面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。 1.1 抽象的进步五大基本特征: 所有东西都是对象 程序是一大堆对象的组合 每个对象都有自己的存储空间，可容">
<meta property="og:image" content="http://yoursite.com/image/chapter001_001.jpg">
<meta property="og:updated_time" content="2016-11-23T14:44:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ThinkInJava">
<meta name="twitter:description" content="第 1 章  对象入门面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。 1.1 抽象的进步五大基本特征: 所有东西都是对象 程序是一大堆对象的组合 每个对象都有自己的存储空间，可容">
<meta name="twitter:image" content="http://yoursite.com/image/chapter001_001.jpg">
  
  
    <link rel="icon" href="/img/mylogo.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/mylogo.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">申建利</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/shenjianli" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Fresco/" style="font-size: 20px;">Fresco</a> <a href="/tags/Glide/" style="font-size: 10px;">Glide</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/Picasso/" style="font-size: 10px;">Picasso</a> <a href="/tags/ShenLib/" style="font-size: 10px;">ShenLib</a> <a href="/tags/cache/" style="font-size: 10px;">cache</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/picasso/" style="font-size: 10px;">picasso</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/分析/" style="font-size: 10px;">分析</a> <a href="/tags/面试/" style="font-size: 20px;">面试</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是一名Android开发人员，欢迎各位光临各位访问指导！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">申建利</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/mylogo.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">申建利</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/shenjianli" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-ThinkInJava" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/16/ThinkInJava/" class="article-date">
  	<time datetime="2016-11-16T13:55:44.000Z" itemprop="datePublished">2016-11-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ThinkInJava
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第-1-章-对象入门"><a href="#第-1-章-对象入门" class="headerlink" title="第 1 章  对象入门"></a>第 1 章  对象入门</h2><p>面向对象编程（OOP）具有多方面的吸引力。对管理人员，它实现了更快和更廉价的开发与维护过程。对分析<br>与设计人员，建模处理变得更加简单，能生成清晰、易于维护的设计方案。对程序员，对象模型显得如此高<br>雅和浅显。此外，面向对象工具以及库的巨大威力使编程成为一项更使人愉悦的任务。</p>
<h3 id="1-1-抽象的进步"><a href="#1-1-抽象的进步" class="headerlink" title="1.1 抽象的进步"></a>1.1 抽象的进步</h3><h4 id="五大基本特征"><a href="#五大基本特征" class="headerlink" title="五大基本特征:"></a>五大基本特征:</h4><ol>
<li>所有东西都是对象</li>
<li>程序是一大堆对象的组合</li>
<li>每个对象都有自己的存储空间，可容纳其他对象。</li>
<li>每个对象都有一种类型</li>
<li>同一类所有对象都能接收相同的消息<h3 id="1-2-对象的接口"><a href="#1-2-对象的接口" class="headerlink" title="1.2 对象的接口"></a>1.2 对象的接口</h3>所有对象——尽管各有特色——都属于某一系列对象的一部分，这些对象具有通用的特征和行为。<br>在面向对象的程序设计中，尽管我们真正要做的是新建各种各样的数据“类型”（Type），但几乎所<br>有面向对象的程序设计语言都采用了“class”关键字。当您看到“type”这个字的时候，请同时想到<br>“class”；反之亦然。<br>如何利用对象完成真正有用的工作呢？必须有一种办法能向对象发出请求，令其做一些实际的事情，比如完<br>成一次交易、在屏幕上画一些东西或者打开一个开关等等。每个对象仅能接受特定的请求。我们向对象发出<br>的请求是通过它的“接口”（Interface）定义的，对象的“类型”或“类”则规定了它的接口形式。“类<br>型”与“接口”的等价或对应关系是面向对象程序设计的基础。<br><img src="/image/chapter001_001.jpg" alt="例子"><h3 id="1-3-实现方案的隐藏"><a href="#1-3-实现方案的隐藏" class="headerlink" title="1.3  实现方案的隐藏"></a>1.3  实现方案的隐藏</h3>“接口”（Interface）规定了可对一个特定的对象发出哪些请求。然而，必须在某个地方存在着一些代码，<br>以便满足这些请求。这些代码与那些隐藏起来的数据便叫作“隐藏的实现”<br>Java 采用三个显式（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public，private，<br>protected 以及暗示性的friendly(default)。若未明确指定其他关键字，则默认为后者。</li>
</ol>
<p>“public”（公共）意味着后续的定义任何人均可使<br>用。</p>
<p>“private”（私有）意味着除您自己、类型的创建者以及那个类型的内部函数成员，其<br>他任何人都不能访问后续的定义信息。private 在您与客户程序员之间竖起了一堵墙。若有人试图访问私有成员，就会得到一个编译期错误。</p>
<p>“friendly (default)”（友好的）涉及“包装”或“封装”（Package）的概念——<br>即 Java 用来构建库的方法。若某样东西是“友好的”，意味着它只能在这个包装的范围内使用（所以这一访问级别有时也叫作“包装访问”）。</p>
<p>“protected”（受保护的）与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员。</p>
<h3 id="1-4-方案的重复使用"><a href="#1-4-方案的重复使用" class="headerlink" title="1.4  方案的重复使用"></a>1.4  方案的重复使用</h3><p>为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。我们把这叫作“创建一个成员对象”。新类可由任意数量和类型的其他对象构成。无论如何，只要新类<br>达到了设计要求即可。这个概念叫作“组织”——在现有类的基础上组织一个新类。有时，我们也将组织称<br>作“包含”关系，比如“一辆车包含了一个变速箱”。</p>
<p>继承的频繁使用会大大增加程序的复杂程度。相反，新建类的时候，首先应考虑“组织”对象；这样做显得更加简单和灵活。利用对象的组织，我们的设计可保持清爽。</p>
<h3 id="1-5-继承：重新使用接口"><a href="#1-5-继承：重新使用接口" class="headerlink" title="1.5  继承：重新使用接口"></a>1.5  继承：重新使用接口</h3><p>在 Java 语言中，继承是通过 extends 关键字实现的 使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏起来，且不能访问），但更重要的是，它复制了基础类的方法。</p>
<h4 id="1-5-1-改善基础类"><a href="#1-5-1-改善基础类" class="headerlink" title="1.5.1   改善基础类"></a>1.5.1   改善基础类</h4><p><strong>重写(Override)</strong>覆盖继承到的那个方法，那个方法仍然没有放弃。<br>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！<br>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。<br>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。<br>在面向对象原则里，重写意味着可以重写任何现有方法。 </p>
<p><strong>重载(overloading)</strong> 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。<br>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>只能重载构造函数<br><strong>overwrite</strong> 重写继承到的那个方法的代码，原方法被放弃<br><strong>重写与重载之间的区别</strong><br>区别点|    重载方法|    重写方法<br>参数列表|    必须修改    |一定不能修改<br>返回类型    |可以修改|    一定不能修改<br>异常    |可以修改|    可以减少或删除，一定不能抛出新的或者更广的异常<br>访问|    可以修改|    一定不能做更严格的限制（可以降低限制）</p>
<p><strong>总结</strong>：方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。</p>
<p><a href="http://www.runoob.com/java/java-override-overload.html" target="_blank" rel="external">重写与重载</a></p>
<h4 id="1-5-2-等价与类似关系"><a href="#1-5-2-等价与类似关系" class="headerlink" title="1.5.2   等价与类似关系"></a>1.5.2   等价与类似关系</h4><p><strong>等价</strong>我们完全能够将衍生类的一<br>个对象换成基础类的一个对象！可将其想象成一种“纯替换”。在某种意义上，这是进行继承的一种理想方<br>式。此时，我们通常认为基础类和衍生类之间存在一种“等价”关系</p>
<p><strong>类似</strong>新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的</p>
<h3 id="1-6-多形对象的互换使用"><a href="#1-6-多形对象的互换使用" class="headerlink" title="1.6  多形对象的互换使用"></a>1.6  多形对象的互换使用</h3><p>继承最终会以创建一系列类收场，所有类都建立在统一的接口基础上</p>
<h4 id="1-6-1-动态绑定"><a href="#1-6-1-动态绑定" class="headerlink" title="1.6.1 动态绑定"></a>1.6.1 动态绑定</h4><p>“多态”(Polymorphic)也叫“动态绑定”(Dynamic Binding)同时也叫“迟绑定”(Late Binding)。</p>
<p>动态绑定是指“在执行期间（而非编译期间）判断所引用对象的实际类型，根据其实际类型调用其相应的方法。”<br>多态必备的三个条件1、有继承2、有重写3、父类引用指向子类对象<br><a href="http://www.cnblogs.com/Gaojiecai/p/4035077.html" target="_blank" rel="external">多态</a></p>
<h4 id="1-6-2-抽象的基础类和接口"><a href="#1-6-2-抽象的基础类和接口" class="headerlink" title="1.6.2   抽象的基础类和接口"></a>1.6.2   抽象的基础类和接口</h4><p><strong>abstarct class</strong></p>
<p><strong>interface（接口）</strong>关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可将多个接口都合并到一起</p>
<p>abstarct class在Java语言中体现了一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is a”关系，即父类和派生类在概念本质上应该是相同的。对于interface 来说则不然，并不要求interface的实现者和interface定义在概念本质上是一致的，仅仅是实现了interface定义的契约而已。</p>
<h3 id="1-7-对象的创建和存在时间"><a href="#1-7-对象的创建和存在时间" class="headerlink" title="1.7 对象的创建和存在时间"></a>1.7 对象的创建和存在时间</h3><p><strong>java对象需要的数据位于哪儿，如何控制对象的“存在时间”呢？</strong></p>
<p>比如 String bb= new String ();new出来的对象放在堆内存中了,bb这个是局部变量放在栈内存</p>
<p>new出来的都放在heap 堆里</p>
<p>stack 是存放局部变量的</p>
<p>data segment 是存放静态变量和字符串常量的</p>
<p>code segment 是存放代码的</p>
<ol>
<li>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</li>
<li>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共 享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。</li>
</ol>
<p>基本类型(primitive types),共有8种，即int, short, long, byte, float, double, boolean,char出于追求速度的原因，就存在于栈中.</p>
<p><strong>栈有一个很重要的特殊性，就是存在栈中的数据可以共享</strong></p>
<p>如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于<strong>堆</strong>中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p>
<p>基本数据类型，存储在栈中，“abc”存储在栈中，只要是使用new一个对象，则存储在堆中，而且在栈中，在新建一个新的变量或对象时，会首 先看一下是否已经存在，存在则不创建新的。那在栈中的数据是否不涉及垃圾回收呢。那这部分内容，如何处理呢，还有就是，对象的作用域，程序存储在哪儿呢<br>对于栈中的数据来说，当超过变量的作用域的时候，会消失。哦，明白了，那种栈的形式</p>
<p>实例化后，也就是用了new运算符号，在堆内存建立一个对象，对象是一块区域，里面包含着每个属性</p>
<p>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。</p>
<p>当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==</p>
<p><a href="http://blog.163.com/lively_caicai/blog/static/209217122201273011938392/" target="_blank" rel="external">java对象需要的数据位于哪儿</a></p>
<p>一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”</p>
<p>若需一个新对象，只需在需要它的时候在<strong>内存堆</strong>里简单地创建<br>它即可。由于存储空间的管理是运行期间动态进行的，所以在内存堆里分配存储空间的时间比在<strong>堆栈</strong>里创建<br>的时间长得多（在堆栈里创建存储空间一般只需要一个简单的指令，将堆栈指针向下或向下移动即可）。由于动态创建方法使对象本来就倾向于复杂，所以查找存储空间以及释放它所需的额外开销不会为对象的创建造成明显的影响。</p>
<p>程序员可用两种方法来破坏一个对象：用程序化的方式决定何时破坏对象，或者利用由运行环境提供的一种<strong>“垃圾收集器”</strong>特性，自动寻找那些不再使用的对象，并将其清除。当然，垃圾收集器显得方便得多，但要求所有应用程序都必须容忍垃圾收集器的存在，并能默许随垃圾收集带来的额外开销。</p>
<h4 id="1-7-1-集合与迭代器"><a href="#1-7-1-集合与迭代器" class="headerlink" title="1.7.1   集合与迭代器"></a>1.7.1   集合与迭代器</h4><p>如果事先不知道需要多少个对象，或者它们的持续时间有多长，那么也不知道如何保存那些对象。既然如此，怎样才能知道那些对象要求多少空间呢？事先上根本无法提前知道，除非进入运行期。 </p>
<p>在需要的时候，<strong>集合会自动扩充自己</strong>，以便适应我们在其中置入的任何东西。所以我们事先不必知道要在一个集合里容下多少东西。只需创建一个集合，以后的工作让它自己负责好了。</p>
<p>根据自己的需要选择适当的类型。其中包括集合、队列、散列表、树、堆栈等等</p>
<p><strong>。如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？</strong></p>
<p>办法就是使用一个<strong>“迭代器”（Iterator）</strong>，它属于一种对象，负责选择集合内的元素，并把它们提供给迭代器的用户。</p>
<p><strong>有两方面的原因促使我们需要对集合作出选择。</strong></p>
<p>首先，集合提供了不同的接口类型以及外部行为。<strong>堆栈</strong>的接口与行为与<strong>队列</strong>的不同，而队列的接口与行为又与一个<strong>集（Set）</strong>或<strong>列表</strong>的不同。利用这个特征，我们解决问题时便有更大的灵活性。</p>
<p>其次，不同的集合在进行特定操作时往往有不同的效率。最好的例子便是<strong>矢量（Vector）</strong>和<strong>列表（List）的区别</strong>。它们都属于简单的序列，拥有完全一致的接口和外部行为。但在执行一些特定的任务时，需要的开销<br>却是完全不同的。对矢量内的元素进行的随机访问（存取）是一种常时操作；无论我们选择的选择是什么，需要的时间量都是相同的。但在一个<strong>链接列表</strong>中，若想到处移动，并随机挑选一个元素，就需付出“惨重”<br>的代价。而且假设某个元素位于列表较远的地方，找到它所需的时间也会长许多。但在另一方面，如果想在序列中部插入一个元素，用列表就比用矢量划算得多。</p>
<h4 id="1-7-2-单根结构"><a href="#1-7-2-单根结构" class="headerlink" title="1.7.2 单根结构"></a>1.7.2 单根结构</h4><p>java所有对象是继承于Object</p>
<p>单根结构中的所有对象（比如所有 Java 对象）都可以保证拥有一些特定的功能。</p>
<p>利用单根结构，我们可以更方便地实现一个垃圾收集器</p>
<h4 id="1-7-3-集合库与方便使用集合"><a href="#1-7-3-集合库与方便使用集合" class="headerlink" title="1.7.3   集合库与方便使用集合"></a>1.7.3   集合库与方便使用集合</h4><p>参数化类型  Java generic泛型 声明的类型参数在使用时用具体的类型来替换</p>
<h4 id="1-7-4-清除时的困境：由谁负责清除？"><a href="#1-7-4-清除时的困境：由谁负责清除？" class="headerlink" title="1.7.4 清除时的困境：由谁负责清除？"></a>1.7.4 清除时的困境：由谁负责清除？</h4><p><strong>如何才能知道什么时间删除对象呢？</strong>用完对象后，系统的其他某些部分可能仍然要发挥作用。同样的问题也会在其他大量场合出现</p>
<p>在 Java 中，垃圾收集器在设计时已考虑到了内存的释放问题（尽管这并不包括清除一个对象涉及到的其他方面）。垃圾收集器“知道”一个对象在什么时候不再使用，然后会自动释放那个对象占据的内存空间。采用这种方式，另外加上所有对象都从单个根类Object 继承的事实，而且由于我们只能在内存堆中以一种方式创建对象，所以Java 的编程要比 C++的编程简单得多。</p>
<p>垃圾收集器对效率及灵活性的影响</p>
<h3 id="1-8-违例控制：解决错误"><a href="#1-8-违例控制：解决错误" class="headerlink" title="1.8 违例控制：解决错误"></a>1.8 违例控制：解决错误</h3><p>“违例控制”将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。这里的“违例”（Exception）属于一个特殊的对象，它会从产生错误的地方“扔”或“掷”出来。随后，这个违例会被设计用于控制特定类型错误的“违例控制器”捕获。</p>
<h3 id="1-9-多线程"><a href="#1-9-多线程" class="headerlink" title="1.9 多线程"></a>1.9 多线程</h3><p>Java 也提供了有限的资源锁定方案。它能锁定任何<br>对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized 关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。 </p>
<p>volatile</p>
<p>应用场景：检查一个应用执行关闭或中断状态。因为此关键字拒绝了虚拟对一个变量多次赋值时的优化从而保证了虚拟机一定会检查被该关键字修饰的变量的状态变化。</p>
<p>CountDownLatch</p>
<p>应用场景：控制在一组线程操作执行完成之前当前线程一直处于等待。例如在主线程中执行await()方法阻塞主线程，在工作线程执行完逻辑后执行countDown()方法。</p>
<p>synchronized：java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p>一、当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。</p>
<p>二、然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。</p>
<p>三、尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。</p>
<p>四、第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。</p>
<p>五、以上规则对其它对象锁同样适用.</p>
<h3 id="1-10-序列化对象有限永久性保存"><a href="#1-10-序列化对象有限永久性保存" class="headerlink" title="1.10 序列化对象有限永久性保存"></a>1.10 序列化对象有限永久性保存</h3><p>serilizable</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/30/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Hexo Command
        
      </div>
    </a>
  
  
    <a href="/2016/11/14/i71/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">i71面试总结</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="ThinkInJava" data-title="ThinkInJava" data-url="http://yoursite.com/2016/11/16/ThinkInJava/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 申建利
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>